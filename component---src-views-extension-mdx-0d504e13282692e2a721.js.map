{"version":3,"sources":["webpack:///../src/views/extension.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"0eAMO,IAAMA,EAAe,Q,yMAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,aADR,aAGA,oSAGA,iBAAQ,CACN,GAAM,iBADR,iBAGA,qIACA,4GAEA,wQAEA,qHACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,gBADZ,kNAQL,iEACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,mIAQL,iBAAQ,CACN,GAAM,gBADR,gBAGA,+CACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,8DAML,yCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,uDAIL,oGAEA,mEACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,qIAKL,2CACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4HAKL,8CACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,+E,gMASTJ,EAAWK,gBAAiB","file":"component---src-views-extension-mdx-0d504e13282692e2a721.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/ts-auto-mock/ts-auto-mock/ui/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"extension\"\n    }}>{`Extension`}</h1>\n    <p>{`To make sure typings are correct we provide some functionality to identify mocks and the original type.\nIf you need your custom spies you can use our framework to specify and identify them.\nIn this way you will avoid casting and it will make your code much cleaner.`}</p>\n    <h2 {...{\n      \"id\": \"custom-method\"\n    }}>{`Custom Method`}</h2>\n    <p>{`(this example is taken from jasmine-ts-auto-mock)`}{`[https://github.com/Typescript-TDD/jasmine-ts-auto-mock]`}</p>\n    <p>{`To extend a method you need to:\n1) set your spy function (jasmine.createSpy(name))`}</p>\n    <p>{`Please note that the value returned from provideMethodWithDeferredValue will be a function.\nYou will need to make sure that the method you are providing will not execute the function directly because it will cause Maximum call stack size.`}</p>\n    <p>{`In the example below it's using callFake that will prevent to execute the function directly.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Provider } from \"ts-auto-mock/extension\";\n\nProvider.instance.provideMethodWithDeferredValue((name: string, value: () => any)) => {\n    return jasmine.createSpy(name).and.callFake(value);\n});\n`}</code></pre>\n    <p>{`2) override the type of the return value`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`type ReturnType = jasmine.Spy;\n\ndeclare module 'ts-auto-mock/extension' {\n  interface Method<TR> extends ReturnType {}\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"method-usage\"\n    }}>{`Method Usage`}</h3>\n    <p>{`1) create an interface`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`interface Interface {\n    methodToSpy: () => string\n}\n`}</code></pre>\n    <p>{`2) create a mock`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const mock: Interface = createMock<Interface>();\n`}</code></pre>\n    <p>{`3) get the spy from the method\nYou can get the method in two different way`}</p>\n    <p>{`through a function that access to the mock`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { On, method } from \"ts-auto-mock/extension\";\nconst spy: jasmine.Spy = On(mock).get(method(mock => mock.methodToSpy));\n`}</code></pre>\n    <p>{`directly as string`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { On, method } from \"ts-auto-mock/extension\";\nconst spy: jasmine.Spy = On(mock).get(method('methodToSpy'));\n`}</code></pre>\n    <p>{`4) trigger the method`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`someMethodThatWillTriggerInterfaceA();\nexpect(spy).toHaveBeenCalled();\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}